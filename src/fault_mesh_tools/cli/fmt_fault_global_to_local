#!/usr/bin/env python3
"""
Simple script to convert either a single mesh file or a directory with
multiple mesh files to local coordinates (best-fit plane) and then
output as a mesh file, along with coordinate conversion metadata.
"""

# The code requires numpy, pathlib, argparse, sys, pickle, meshio,
# and the fault_mesh_tools.faultmeshops package.
import numpy as np

from pathlib import Path
import argparse
import sys
import pickle

import meshio

from fault_mesh_tools.faultmeshops import faultmeshops

# Metadata file suffix.
md_suffix = '.pkl'

# ----------------------------------------------------------------------
def convert_file(in_file, out_root, out_suffix, preferred_ref_dir):
    """
    Function to read a mesh file and output a mesh file in local coordinates,
    along with metadata (in a pickle file).
    """

    out_mesh = out_root.with_suffix(out_suffix)
    out_md = out_root.with_suffix(md_suffix)
    
    # Read input file.
    mesh = meshio.read(in_file)
    points = mesh.points
    cells = mesh.cells

    # Get best-fit plane through points and rotation matrix.
    (plane_normal, plane_origin) = faultmeshops.fit_plane_to_points(points, eps=1.0e-5)
    rotation_matrix = faultmeshops.get_fault_rotation_matrix(plane_normal, cutoff_vecmag=0.98, preferred_ref_dir=preferred_ref_dir)
    (rotation_axis, rotation_angle) = faultmeshops.axis_angle_from_rotation_matrix(rotation_matrix)
    
    # Local coordinates.
    (points_local, edges_local, fault_is_plane) = faultmeshops.fault_global_to_local(points, rotation_matrix, plane_origin)

    # Write coordinate info to pickle file.
    surface_info = {"plane_normal": plane_normal,
                    "plane_origin": plane_origin,
                    "rotation_axis": rotation_axis,
                    "rotation_angle": rotation_angle,
                    "fault_is_plane": fault_is_plane}
    f = open(out_md, "wb")
    pickle.dump(surface_info, f)
    f.close()

    # Write mesh in local coordinates.
    meshLocal = meshio.Mesh(points_local, cells)
    meshio.write(out_mesh, meshLocal)

    return
    

def convert_dir(in_path, out_path, in_qualifier, out_qualifier, in_suffix, out_suffix, preferred_ref_dir, verbose):
    """
    Function to convert a directory of mesh files to mesh files in local coordinates.
    """
    in_search = '*' + in_suffix
    in_files = sorted(in_path.glob(in_search))
    for in_file in in_files:
        in_stem = in_file.stem
        out_stem = in_stem
        if (verbose):
            print("Input file:  %s" % in_stem)
        if (in_qualifier):
            out_stem = in_stem.replace(in_qualifier, out_qualifier)
        elif (out_qualifier):
            out_stem = in_stem + out_qualifier
        out_root = Path.joinpath(out_path, out_stem)
        convert_file(in_file, out_root, out_suffix, preferred_ref_dir)

    return

  
# ======================================================================
if __name__ == "__main__":

    # Get command-line arguments.
    parser = argparse.ArgumentParser(description='Convert one or more mesh files to mesh files in local coordinates.')
    parser.add_argument("-i", "--in_files", action="store", 
                        dest="in_files", required=True, help="input file or directory")
    parser.add_argument("-iq", "--in_qualifier", action="store", 
                        dest="in_qualifier", default=None, help="additional input filename qualifier following unique string")
    parser.add_argument("-o", "--out_directory", action="store", 
                        dest="out_directory", required=True, help="output directory")
    parser.add_argument("-oq", "--out_qualifier", action="store", 
                        dest="out_qualifier", default="_local", help="additional output filename qualifier following unique string")
    parser.add_argument("-is", "--in_suffix", action="store", 
                        dest="in_suffix", default=".vtk", help="suffix of input file(s)")
    parser.add_argument("-os", "--out_suffix", action="store", 
                        dest="out_suffix", default=".stl", help="suffix of output file(s)")
    parser.add_argument("-pd", "--preferred_ref_dir", action="store", nargs=3, metavar=('v1', 'v2', 'v3'), type=float,
                        dest="preferred_ref_dir", default=None, help="preferred reference direction vector perpendicular to plane normal")
    parser.add_argument("-v", "--verbose", action="store_true", 
                        dest="verbose", default=False, help="verbose output for directories")

    args = parser.parse_args()

    in_path = Path(args.in_files)
    out_dir = Path(args.out_directory)
    out_dir.mkdir(parents=True, exist_ok=True)
    in_qualifier = args.in_qualifier
    out_qualifier = args.out_qualifier
    in_suffix = args.in_suffix
    out_suffix = args.out_suffix
    if (args.preferred_ref_dir):
        preferred_ref_dir = np.array(args.preferred_ref_dir)
    verbose = args.verbose

    # Case 1:  Convert single file.
    if (in_path.is_file()):
        in_suff = in_path.suffix
        in_stem = in_path.stem
        if (in_suff != in_suffix):
            msg = 'Filename does not match in_suffix.'
            raise ValueError(msg)
        out_stem = in_stem
        if (in_qualifier):
            out_stem = in_stem.replace(in_qualifier, out_qualifier)
        elif (out_qualifier):
            out_stem = in_stem + out_qualifier
        out_path = Path.joinpath(out_dir, out_stem)
        convert_file(in_path, out_path, out_suffix, preferred_ref_dir)
    # Case 2:  Convert directory.
    elif (in_path.is_dir()):
        convert_dir(in_path, out_dir, in_qualifier, out_qualifier, in_suffix, out_suffix, preferred_ref_dir, verbose)
    # Case 3:  Give up.
    else:
        msg = 'Unable to find %s.' % in_path
        raise ValueError(msg)
    
